今天为啥又聊 Merkle Tree 呢？ 这个我们地球上大部分人应该连名字都没有听过，而且也是个比较传统的概念了。Merkle Tree 是由 Ralph Merkle 这位计算机科学家在很多年前提出的。但是 Merkle Tree 确实涉及到了很有意思的应用，最近几年才有的一个实用例子：比特币钱包服务用 Merkle Tree 的机制来作”百分百准备金证明“ （ <http://blog.bifubao.com/2014/03/16/proof-of-reserves/> ）。不过今天，我们还是从数据完整性校验的这个角度来聊 merkle tree。 git 版本控制系统，zfs 文件系统以及我们自己下片常用的 bt 下载，都是通过 merkle tree 来进行数据完整性校验(Integrity Verification)的。

### 先说哈希( hash )

哈希的最大特点是，如果你的输入数据，稍微变了一点点，那么经过哈希运算，你得到的哈希值将会变得面目全非。好的哈希算法就是这样，这样做的一个目的是可以防止有人根据哈希值反推出原始输入数据的一些特征。


### 再说哈希列表（hash list）

我们可以把数据分成很多的小块，每个小块拿到它的哈希，这样我们就可以以小块为单位来下载数据了，如果一个小块出了问题
那么我只需要重新下载这个小块就可以了，而不用下载整个的数据文件。但是这时有一个问题就出现了，那么多的哈希，我们怎么保证它们都是正确地呢？这里我们就需要一个根哈希了。
  - root hash 必须得从一个可信的来源获取，有了这个 hash list 从哪里获取都无所谓了


### 最后是 merkle tree

好，有了哈希列表（list）我们可以通过一个 root 哈希来判断各个块的哈希是否真确，继而就可以确认每个数据块是否有损坏了，挺好但是还是不够好。试想，如果我们下面的 100 万个数据块中有一个发生了数据损坏，那么我们怎么才能检测到呢？
  - 另一个问题，如果一个数据块我们收到了，那么如何确定它的位置呢？
  - https://www.youtube.com/watch?v=Js535LqapFE#t=238 给出了 merkle tree 相对于 hash list 的优势。

