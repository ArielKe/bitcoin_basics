“逻辑完备性”？
- 这样来想这个问题：平台公布的那些辅助节点有没有可能有造假
  - 平台本来有 10000 个币，但是他挪用了 2000，那么这时平台公布 merkle tree 的时候
    - 首先我那个节点他不可能造假，因为我自己可以直接算出来的
    - 然后他就要在给我的 root to patch 哪些辅助节点上造假
      - 平台可以给一个假的余额，肯定要比真实地小，因为要保证算到 merkle root 的时候是 8000
      - 这时候哈希可以是原来的哈希，因为反正我也不能验证这个节点本身的余额和哈希的关系
      - 但是向上推的时候就有了问题，一个余额造假，但是哈希为真的节点，不能和我自己的一个真节点共同算出一个真实地父哈希
      - 所以想保持哈希不变，而对于余额造假是不可能得
    - 另外一种造假方式
      - 平台从最底层就造假，删除了一部分用户，这样当然可以一路算到 merkle root 得到 8000 的
      - 同时这样，我是没有能力去验证的，因为这本身就是一个完全合法的树
      - 但是问题是，平台在给那些被删掉的用户，提供 tree 的时候，那么必然提供的是“另一个 tree"
      - 所以只要大家看到同一时间，merkle root 不相等，就证明平台造假了


有一个关键点要把握，hash 算法的特性决定了，没有任何方法可以伪造一个哈希算法的输入。这就意味着，我自己可以通过我自己的信息（用户名和余额）来运算出我自己的哈希，这个当然是可以信赖的，同时平台必须提供其他的节点，以便我能自己 path to root 这样才能完成证明。那么这些平台提供的节点是不是可以伪造呢？也就是说哈希对应的那个账户中根本就没有那些余额？
这是个好问题，我们来分析一下。
  - 比如这节点的余额是 0.4367，那么我试图改变这个余额中得任何一位数，那么我就绝对得不到相同的哈希了。
  - 同时只要大家看到的是同一个 Merkle root 那么就证明大家同时看到的是同一颗 tree，这个 tree 上的每一个节点的 hash 也就都固定了。

- bifubao proof-of-reserves
  - get my account hash 
    hashlib.sha256("happypeter1983@gmail.com0278730000000014990000").hexdigest()

  - 然后我的父节点的 hash 这样得到

			hexstr(
			    first8bytes(
			        sha256(_8bytes(left.sum + right.sum) + _8bytes(left.hash) + _8bytes(right.hash))
			    )
			)


大家如果保证看到的都是同一棵树：
- 只要 Merkle root 的跟哈希一样，那么我们就可以断言，这棵树是一样的，因为没有人能够伪造出 hash 算法的输入（也就是弄出区别于真实输入的另外一组输入），所以只要每个用户都可以通过自己的 hash，推算出 Merkle root 来，并且不同的人看到的 Merkle root 都是一样的，那么大家就肯定看的是同一棵树。


- 是不是给定 merkle root 我们不能构造出另外一种 tree 的节点布局，同时也不能更改任何一个节点的哈希值？
  - 应该是这样，哈希不能反运算，稍有改动就凑不出原有的结果了

- 为什么要 nonce

- 冷钱包签名的验证部分很有意思啊：http://blog.bifubao.com/2014/03/16/proof-of-reserves/
